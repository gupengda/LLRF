--------------------------------------------------------------------------------
-- Filename:          user_logic.vhd
-- Version:           v1_00_a
-- Description:       User Logic implementation module
-- Generated by:      khalid.bensadek
-- Date:              2012-07-07 15:17:32
-- Generated:         using LyrtechRD REGGENUTIL based on Xilinx IPIF Wizard.
-- VHDL Standard:     VHDL'93
------------------------------------------------------------------------------
-- Copyright (c) 2001-2012 LYRtech RD Inc.  All rights reserved.
------------------------------------------------------------------------------
--
-----------------------------------------------------------------------------
-- Register Memory Map & Description
-----------------------------------------------------------------------------
-- BASEADDR + 0x0   INFO    0
--   15:0 Version R
--   31:16 CoreID R

-- BASEADDR + 0x4   CONTROL    1
--   0:0 MemReset R W O=o_MemReset_p
--   1:1 CoreReset R W O=o_CoreReset_p
--   2:2 PhyInitDone R I=i_PhyInitDone_p
--   31:3 rsvd R

-- BASEADDR + 0x8   SET_MODE    2
--   0:0 SetMode R W O=o_SetMode_p
--   31:1 rsvd R

-- BASEADDR + 0xc   MODE_VALUE    3
--   2:0 ModeValue R W O=ov3_ModeValue_p
--   31:3 rsvd R

-- BASEADDR + 0x10   SET_START_ADDRESS    4
--   0:0 SetStartAddress R W O=o_SetStartAddress_p
--   31:1 rsvd R

-- BASEADDR + 0x14   START_ADDRESS    5
--   31:0 StartAddress R W O=ov32_StartAddress_p

-- BASEADDR + 0x18   DELAY_VAL    6
--   31:0 TrigDly R W O=ov32_TrigDly_p

-- BASEADDR + 0x1c   SET_TRANSFER_SIZE    7
--   0:0 SetTransferSize R W O=o_SetTransferSize_p
--   31:1 rsvd R

-- BASEADDR + 0x20   TRANSFER_SIZE    8
--   31:0 TransferSize R W O=ov32_TransferSize_p

-- BASEADDR + 0x24   TRIG_ADDRESS    9
--   31:0 TrigAddr R I=iv32_TrigAddr_p

-- BASEADDR + 0x28   TRIG_ADDRESS_INDEX    10
--   31:0 TrigAddrIndex R I=iv32_TrigAddrIndex_p

-- BASEADDR + 0x2c   TRANSFER_OVER    11
--   0:0 TransferOver R I=i_TransferOver_p
--   31:1 rsvd R

-- BASEADDR + 0x30   MODE_RECORD    12
--   2:0 ModeRecordValue R I=iv3_ModeRecordValue_p
--   31:3 rsvd R

-- BASEADDR + 0x34   MODE_PLAYBACKSINGLE    13
--   2:0 ModePlayBackSingleValue R I=iv3_ModePlayBackSingleValue_p
--   31:3 rsvd R

-- BASEADDR + 0x38   MODE_PLAYBACKCONTINUOUS    14
--   2:0 ModePlayBackContinuousValue R I=iv3_ModePlayBackContinuousValue_p
--   31:3 rsvd R

-- BASEADDR + 0x3c   MODE_RTDEXMEM2HOST    15
--   2:0 ModeRtdex2HostValue R I=iv3_ModeRtdex2HostValue_p
--   31:3 rsvd R

-- BASEADDR + 0x40   MODE_RTDEXHOST2MEM    16
--   2:0 ModeHost2RtdexValue R I=iv3_ModeHost2RtdexValue_p
--   31:3 rsvd R

-- BASEADDR + 0x44   UNDERRUN_FLAGS    17
--   0:0 UnderRunFlag R W I=i_UnderRunFlag_p
--   31:1 rsvd R

-- BASEADDR + 0x48   OVERRUN_FLAGS    18
--   0:0 OverRunFlag R W I=i_OverRunFlag_p
--   31:1 rsvd R

-- BASEADDR + 0x4c   PROG_FULL_THRES_ASSERT    19
--   31:8 rsvd R
--   8:0 ProgFullThresAssert R W O=ov9_ProgFullThresAssert_p

-- BASEADDR + 0x50   PROG_FULL_THRES_NEGATE    20
--   31:8 rsvd R
--   8:0 ProgFullThresNegate R W O=ov9_ProgFullThresNegate_p

-- BASEADDR + 0x54   PARITY_ADDR_REG    21
--   0:0 ParityAddrReg R I=i_ParityAddrReg_p
--   31:1 rsvd R

-- BASEADDR + 0x58   NB_RECORD_PORTS    22
--   31:0 NbRecordPorts R I=iv32_NbRecordPorts_p

-- BASEADDR + 0x5c   NB_PLAYBACK_PORTS    23
--   31:0 NbPlaybackPorts R I=iv32_NbPlaybackPorts_p

-- BASEADDR + 0x60   RECORD_PORTS_WIDTH    24
--   31:0 RecordPortsWidth R I=iv32_RecordPortsWidth_p

-- BASEADDR + 0x64   PLAYBACK_PORTS_WIDTH    25
--   31:0 PlaybackPortsWidth R I=iv32_PlaybackPortsWidth_p

-- BASEADDR + 0x68   RECORD_TRIG_MUX    26
--   0:0 RecTrigMux R W O=o_RecTrigMux_p
--   31:1 rsvd R

-- BASEADDR + 0x6c   RECORD_SOFT_TRIG    27
--   0:0 RecSoftTrig R W O=o_RecSoftTrig_p
--   31:1 rsvd R

-- BASEADDR + 0x70   MODE_VALIDATION    28
--   2:0 ModeValidationValue R I=iv3_ModeValidationValue_p
--   31:3 rsvd R

-- BASEADDR + 0x74   PLAYBACK_TRIG_MUX    29
--   0:0 PlayTrigMux R W O=o_PlayTrigMux_p
--   31:1 rsvd R

-- BASEADDR + 0x78   PLAYBACK_SOFT_TRIG    30
--   0:0 PlaySoftTrig R W O=o_PlaySoftTrig_p
--   31:1 rsvd R

-- BASEADDR + 0x7c   DDR3_SIZE    31
--   31:0 Ddr3Size R W

-- BASEADDR + 0x80   RECORD_STORAGE_CNT    32
--   31:0 RecordStorageCnt R I=iv32_RecordStorageCnt_p

-- BASEADDR + 0x84   RTDEX_STORAGE_CNT    33
--   31:0 RtdexStorageCnt R I=iv32_RtdexStorageCnt_p

-- BASEADDR + 0x88   PLAYBACK_READ_CNT    34
--   31:0 PlaybackReadCnt R I=iv32_PlaybackReadCnt_p

-- BASEADDR + 0x8c   RTDEX_READ_CNT    35
--   31:0 RtdexReadCnt R I=iv32_RtdexReadCnt_p

--------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

library proc_common_v3_00_a;
use proc_common_v3_00_a.proc_common_pkg.all;

-- DO NOT EDIT ABOVE THIS LINE --------------------

--USER libraries added here

------------------------------------------------------------------------------
-- Entity section
------------------------------------------------------------------------------
-- Definition of Generics:
--   C_NUM_REG                    -- Number of software accessible registers
--   C_SLV_DWIDTH                 -- Slave interface data bus width
--
-- Definition of Ports:
--   Bus2IP_Clk                   -- Bus to IP clock
--   Bus2IP_Resetn                -- Bus to IP reset
--   Bus2IP_Data                  -- Bus to IP data bus
--   Bus2IP_BE                    -- Bus to IP byte enables
--   Bus2IP_RdCE                  -- Bus to IP read chip enable
--   Bus2IP_WrCE                  -- Bus to IP write chip enable
--   IP2Bus_Data                  -- IP to Bus data bus
--   IP2Bus_RdAck                 -- IP to Bus read transfer acknowledgement
--   IP2Bus_WrAck                 -- IP to Bus write transfer acknowledgement
--   IP2Bus_Error                 -- IP to Bus error response
------------------------------------------------------------------------------

entity user_logic is
  generic
  (
    -- ADD USER GENERICS BELOW THIS LINE ---------------
    --USER generics added here
    -- ADD USER GENERICS ABOVE THIS LINE ---------------

    -- DO NOT EDIT BELOW THIS LINE ---------------------
    -- Bus protocol parameters, do not add to or delete
    C_NUM_REG                      : integer              := 36;
    C_SLV_DWIDTH                   : integer              := 32
    -- DO NOT EDIT ABOVE THIS LINE ---------------------
  );
  port
  (
    -- ADD USER PORTS BELOW THIS LINE ------------------
    --USER ports added here
    -- ADD USER PORTS ABOVE THIS LINE ------------------
    -- User ports
    i_logicRst_p : in std_logic;
    o_MemReset_p : out std_logic;
    o_CoreReset_p : out std_logic;
    i_PhyInitDone_p : in std_logic;
    o_SetMode_p : out std_logic;
    ov3_ModeValue_p : out std_logic_vector(2 downto 0);
    o_SetStartAddress_p : out std_logic;
    ov32_StartAddress_p : out std_logic_vector(31 downto 0);
    ov32_TrigDly_p : out std_logic_vector(31 downto 0);
    o_SetTransferSize_p : out std_logic;
    ov32_TransferSize_p : out std_logic_vector(31 downto 0);
    iv32_TrigAddr_p : in std_logic_vector(31 downto 0);
    iv32_TrigAddrIndex_p : in std_logic_vector(31 downto 0);
    i_TransferOver_p : in std_logic;
    iv3_ModeRecordValue_p : in std_logic_vector(2 downto 0);
    iv3_ModePlayBackSingleValue_p : in std_logic_vector(2 downto 0);
    iv3_ModePlayBackContinuousValue_p : in std_logic_vector(2 downto 0);
    iv3_ModeRtdex2HostValue_p : in std_logic_vector(2 downto 0);
    iv3_ModeHost2RtdexValue_p : in std_logic_vector(2 downto 0);
    i_UnderRunFlag_p : in std_logic;
    i_OverRunFlag_p : in std_logic;
    ov9_ProgFullThresAssert_p : out std_logic_vector(8 downto 0);
    ov9_ProgFullThresNegate_p : out std_logic_vector(8 downto 0);
    i_ParityAddrReg_p : in std_logic;
    iv32_NbRecordPorts_p : in std_logic_vector(31 downto 0);
    iv32_NbPlaybackPorts_p : in std_logic_vector(31 downto 0);
    iv32_RecordPortsWidth_p : in std_logic_vector(31 downto 0);
    iv32_PlaybackPortsWidth_p : in std_logic_vector(31 downto 0);
    o_RecTrigMux_p : out std_logic;
    o_RecSoftTrig_p : out std_logic;
    iv3_ModeValidationValue_p : in std_logic_vector(2 downto 0);
    o_PlayTrigMux_p : out std_logic;
    o_PlaySoftTrig_p : out std_logic;
    iv32_RecordStorageCnt_p : in std_logic_vector(31 downto 0);
    iv32_RtdexStorageCnt_p : in std_logic_vector(31 downto 0);
    iv32_PlaybackReadCnt_p : in std_logic_vector(31 downto 0);
    iv32_RtdexReadCnt_p : in std_logic_vector(31 downto 0);
    -- Bus protocol ports, do not add to or delete
    Bus2IP_Clk                     : in  std_logic;
    Bus2IP_Resetn                  : in  std_logic;
    Bus2IP_Data                    : in  std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    Bus2IP_BE                      : in  std_logic_vector(C_SLV_DWIDTH/8-1 downto 0);
    Bus2IP_RdCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    Bus2IP_WrCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    IP2Bus_Data                    : out std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    IP2Bus_RdAck                   : out std_logic;
    IP2Bus_WrAck                   : out std_logic;
    IP2Bus_Error                   : out std_logic
  );

 attribute MAX_FANOUT : string;
 attribute SIGIS : string;
 attribute SIGIS of Bus2IP_Clk    : signal is "CLK";
 attribute SIGIS of Bus2IP_Resetn : signal is "RST";

end entity user_logic;

------------------------------------------------------------------------------
-- Architecture section
------------------------------------------------------------------------------

architecture IMP of user_logic is

-------------------------------------------------------------------------------
-- Constant declarations
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--     ************** Function declaratin *******************
-- Return a std_logic_vector with only one bit set to one.
-- The argument BitPosition represent the bit position to set to one, starting with 0.
-- The argument Width represent the width of the returned std_logic_vector.
-------------------------------------------------------------------------------
  function OneHotVector( BitPosition : integer;
                Width : integer)
                return std_logic_vector
  is
    variable Result                   : std_logic_vector(Width - 1 downto 0);

  begin
    Result := (others => '0');
    Result(BitPosition) := '1';
    return Result;
  end OneHotVector;

  -------------------------------------------------------------------------------
  -- Signal and Type Declarations
  -------------------------------------------------------------------------------

  signal MemReset_s                   : std_logic;
  signal CoreReset_s                  : std_logic;
  signal SetMode_s                    : std_logic;
  signal v3_ModeValue_s               : std_logic_vector(2 downto 0);
  signal SetStartAddress_s            : std_logic;
  signal v32_StartAddress_s           : std_logic_vector(31 downto 0);
  signal v32_TrigDly_s                : std_logic_vector(31 downto 0);
  signal SetTransferSize_s            : std_logic;
  signal v32_TransferSize_s           : std_logic_vector(31 downto 0);
  signal UnderRunFlag_s               : std_logic;
  signal OverRunFlag_s                : std_logic;
  signal v9_ProgFullThresAssert_s                     : std_logic_vector(8 downto 0);
  signal v9_ProgFullThresNegate_s                     : std_logic_vector(8 downto 0);
  signal RecTrigMux_s                 : std_logic;
  signal RecSoftTrig_s                : std_logic;
  signal PlayTrigMux_s                : std_logic;
  signal PlaySoftTrig_s               : std_logic;
  signal v32_Ddr3Size_s               : std_logic_vector(31 downto 0) := (others => '0');
  signal slv_reg_write_sel            : std_logic_vector(35 downto 0);
  signal slv_reg_read_sel             : std_logic_vector(35 downto 0);
  signal slv_ip2bus_data              : std_logic_vector(C_SLV_DWIDTH-1 downto 0);
  signal slv_read_ack                 : std_logic;
  signal slv_write_ack                : std_logic;

------------------------------------------------------------------------------
begin
------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Begin architecture
-------------------------------------------------------------------------------

-- swap bits
WrCeBitSwap: for i in 0 to slv_reg_write_sel'high generate
  slv_reg_write_sel(i) <= Bus2IP_WrCE(slv_reg_write_sel'high - i);
end generate WrCeBitSwap;

RdCeBitSwap: for i in 0 to slv_reg_read_sel'high generate
  slv_reg_read_sel(i)  <= Bus2IP_RdCE(slv_reg_read_sel'high - i);
end generate RdCeBitSwap;

-- generate write/read ack
  slv_write_ack <=   Bus2IP_WrCE(0) or   Bus2IP_WrCE(1) or   Bus2IP_WrCE(2) or   Bus2IP_WrCE(3) or   Bus2IP_WrCE(4) or   Bus2IP_WrCE(5) or   Bus2IP_WrCE(6) or   Bus2IP_WrCE(7) or   Bus2IP_WrCE(8) or   Bus2IP_WrCE(9) or   Bus2IP_WrCE(10) or   Bus2IP_WrCE(11) or   Bus2IP_WrCE(12) or   Bus2IP_WrCE(13) or   Bus2IP_WrCE(14) or   Bus2IP_WrCE(15) or   Bus2IP_WrCE(16) or   Bus2IP_WrCE(17) or   Bus2IP_WrCE(18) or   Bus2IP_WrCE(19) or   Bus2IP_WrCE(20) or   Bus2IP_WrCE(21) or   Bus2IP_WrCE(22) or   Bus2IP_WrCE(23) or   Bus2IP_WrCE(24) or   Bus2IP_WrCE(25) or   Bus2IP_WrCE(26) or   Bus2IP_WrCE(27) or   Bus2IP_WrCE(28) or   Bus2IP_WrCE(29) or   Bus2IP_WrCE(30) or   Bus2IP_WrCE(31) or   Bus2IP_WrCE(32) or   Bus2IP_WrCE(33) or   Bus2IP_WrCE(34) or   Bus2IP_WrCE(35);
  slv_read_ack  <=   Bus2IP_RdCE(0) or   Bus2IP_RdCE(1) or   Bus2IP_RdCE(2) or   Bus2IP_RdCE(3) or   Bus2IP_RdCE(4) or   Bus2IP_RdCE(5) or   Bus2IP_RdCE(6) or   Bus2IP_RdCE(7) or   Bus2IP_RdCE(8) or   Bus2IP_RdCE(9) or   Bus2IP_RdCE(10) or   Bus2IP_RdCE(11) or   Bus2IP_RdCE(12) or   Bus2IP_RdCE(13) or   Bus2IP_RdCE(14) or   Bus2IP_RdCE(15) or   Bus2IP_RdCE(16) or   Bus2IP_RdCE(17) or   Bus2IP_RdCE(18) or   Bus2IP_RdCE(19) or   Bus2IP_RdCE(20) or   Bus2IP_RdCE(21) or   Bus2IP_RdCE(22) or   Bus2IP_RdCE(23) or   Bus2IP_RdCE(24) or   Bus2IP_RdCE(25) or   Bus2IP_RdCE(26) or   Bus2IP_RdCE(27) or   Bus2IP_RdCE(28) or   Bus2IP_RdCE(29) or   Bus2IP_RdCE(30) or   Bus2IP_RdCE(31) or   Bus2IP_RdCE(32) or   Bus2IP_RdCE(33) or   Bus2IP_RdCE(34) or   Bus2IP_RdCE(35);

 -- implement slave model software accessible register(s)
 SLAVE_REG_WRITE_PROC : process( Bus2IP_Clk ) is
 begin

  if Bus2IP_Clk'event and Bus2IP_Clk = '1' then
    if (Bus2IP_Resetn = '0' or i_logicRst_p = '1') then
    --if (Bus2IP_Resetn = '0') then
      MemReset_s <= '0';
      CoreReset_s <= '0';
      SetMode_s <= '0';
      v3_ModeValue_s <= "000";
      SetStartAddress_s <= '0';
      v32_StartAddress_s <= x"00000000";
      v32_TrigDly_s <= x"00000000";
      SetTransferSize_s <= '0';
      v32_TransferSize_s <= x"00000000";
      UnderRunFlag_s <= '0';
      OverRunFlag_s <= '0';
      v9_ProgFullThresAssert_s <= "000000000";
      v9_ProgFullThresNegate_s <= "000000000";
      RecTrigMux_s <= '0';
      RecSoftTrig_s <= '0';
      PlayTrigMux_s <= '0';
      PlaySoftTrig_s <= '0';

    else

      CoreReset_s <= '0';
      SetMode_s <= '0';
      SetStartAddress_s <= '0';
      SetTransferSize_s <= '0';

      if( i_UnderRunFlag_p = '1' ) then
        UnderRunFlag_s <= '1';
      end if;

      if( i_OverRunFlag_p = '1' ) then
        OverRunFlag_s <= '1';
      end if;


      case slv_reg_write_sel is

        when OneHotVector(1,36) =>
          if (Bus2IP_BE(0) = '1') then
            MemReset_s <= Bus2IP_Data(0);
          end if;
          if (Bus2IP_BE(0) = '1') then
            CoreReset_s <= Bus2IP_Data(1);
          end if;

        when OneHotVector(2,36) =>
          if (Bus2IP_BE(0) = '1') then
            SetMode_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(3,36) =>
          if (Bus2IP_BE(0) = '1') then
            v3_ModeValue_s <= Bus2IP_Data(2 downto 0);
          end if;

        when OneHotVector(4,36) =>
          if (Bus2IP_BE(0) = '1') then
            SetStartAddress_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(5,36) =>
          if (Bus2IP_BE(0) = '1') then
            v32_StartAddress_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v32_StartAddress_s(15 downto 8) <= Bus2IP_Data(15 downto 8);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v32_StartAddress_s(23 downto 16) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v32_StartAddress_s(31 downto 24) <= Bus2IP_Data(31 downto 24);
          end if;

        when OneHotVector(6,36) =>
          if (Bus2IP_BE(0) = '1') then
            v32_TrigDly_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v32_TrigDly_s(15 downto 8) <= Bus2IP_Data(15 downto 8);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v32_TrigDly_s(23 downto 16) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v32_TrigDly_s(31 downto 24) <= Bus2IP_Data(31 downto 24);
          end if;

        when OneHotVector(7,36) =>
          if (Bus2IP_BE(0) = '1') then
            SetTransferSize_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(8,36) =>
          if (Bus2IP_BE(0) = '1') then
            v32_TransferSize_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v32_TransferSize_s(15 downto 8) <= Bus2IP_Data(15 downto 8);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v32_TransferSize_s(23 downto 16) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v32_TransferSize_s(31 downto 24) <= Bus2IP_Data(31 downto 24);
          end if;

        when OneHotVector(17,36) =>
          if (Bus2IP_BE(0) = '1') then
            UnderRunFlag_s <= '0';
          end if;

        when OneHotVector(18,36) =>
          if (Bus2IP_BE(0) = '1') then
            OverRunFlag_s <= '0';
          end if;

        when OneHotVector(19,36) =>
          if (Bus2IP_BE(0) = '1') then
            v9_ProgFullThresAssert_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v9_ProgFullThresAssert_s(8 downto 8) <= Bus2IP_Data(8 downto 8);
          end if;

        when OneHotVector(20,36) =>
          if (Bus2IP_BE(0) = '1') then
            v9_ProgFullThresNegate_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v9_ProgFullThresNegate_s(8 downto 8) <= Bus2IP_Data(8 downto 8);
          end if;

        when OneHotVector(26,36) =>
          if (Bus2IP_BE(0) = '1') then
            RecTrigMux_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(27,36) =>
          if (Bus2IP_BE(0) = '1') then
            RecSoftTrig_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(29,36) =>
          if (Bus2IP_BE(0) = '1') then
            PlayTrigMux_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(30,36) =>
          if (Bus2IP_BE(0) = '1') then
            PlaySoftTrig_s <= Bus2IP_Data(0);
          end if;

        when OneHotVector(31,36) =>
          if (Bus2IP_BE(0) = '1') then
            v32_Ddr3Size_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v32_Ddr3Size_s(15 downto 8) <= Bus2IP_Data(15 downto 8);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v32_Ddr3Size_s(23 downto 16) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v32_Ddr3Size_s(31 downto 24) <= Bus2IP_Data(31 downto 24);
          end if;
        when others =>
          null;
      end case;
    end if;
  end if;

 end process SLAVE_REG_WRITE_PROC;

 -- implement slave model software accessible register(s) read mux
SLAVE_REG_READ_PROC : process( slv_reg_read_sel, MemReset_s, CoreReset_s, i_PhyInitDone_p, SetMode_s, v3_ModeValue_s, SetStartAddress_s, v32_StartAddress_s, v32_TrigDly_s, SetTransferSize_s, v32_TransferSize_s, iv32_TrigAddr_p, iv32_TrigAddrIndex_p, i_TransferOver_p, iv3_ModeRecordValue_p, iv3_ModePlayBackSingleValue_p, iv3_ModePlayBackContinuousValue_p, iv3_ModeRtdex2HostValue_p, iv3_ModeHost2RtdexValue_p, i_UnderRunFlag_p, OverRunFlag_s, v9_ProgFullThresAssert_s, v9_ProgFullThresNegate_s, i_ParityAddrReg_p, iv32_NbRecordPorts_p, iv32_NbPlaybackPorts_p, iv32_RecordPortsWidth_p, iv32_PlaybackPortsWidth_p, RecTrigMux_s, RecSoftTrig_s, iv3_ModeValidationValue_p, PlayTrigMux_s, PlaySoftTrig_s, v32_Ddr3Size_s, iv32_RecordStorageCnt_p, iv32_RtdexStorageCnt_p, iv32_PlaybackReadCnt_p, iv32_RtdexReadCnt_p) is
 begin
   case slv_reg_read_sel is

        when OneHotVector(0,36) =>
          slv_ip2bus_data(15 downto 0) <= X"0202";
          slv_ip2bus_data(31 downto 16) <= X"EA00";

        when OneHotVector(1,36) =>
          slv_ip2bus_data(0) <= MemReset_s;
          slv_ip2bus_data(1) <= CoreReset_s;
          slv_ip2bus_data(2) <= i_PhyInitDone_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(2,C_NUM_REG) =>
          slv_ip2bus_data(0) <= SetMode_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(3,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= v3_ModeValue_s;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(4,C_NUM_REG) =>
          slv_ip2bus_data(0) <= SetStartAddress_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(5,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= v32_StartAddress_s;

        when OneHotVector(6,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= v32_TrigDly_s;

        when OneHotVector(7,C_NUM_REG) =>
          slv_ip2bus_data(0) <= SetTransferSize_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(8,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= v32_TransferSize_s;

        when OneHotVector(9,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_TrigAddr_p;

        when OneHotVector(10,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_TrigAddrIndex_p;

        when OneHotVector(11,C_NUM_REG) =>
          slv_ip2bus_data(0) <= i_TransferOver_p;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(12,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModeRecordValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(13,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModePlayBackSingleValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(14,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModePlayBackContinuousValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(15,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModeRtdex2HostValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(16,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModeHost2RtdexValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(17,C_NUM_REG) =>
          slv_ip2bus_data(0) <= UnderRunFlag_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(18,C_NUM_REG) =>
          slv_ip2bus_data(0) <= OverRunFlag_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(19,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 8) <= x"000000";
          slv_ip2bus_data(8 downto 0) <= v9_ProgFullThresAssert_s;

        when OneHotVector(20,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 8) <= x"000000";
          slv_ip2bus_data(8 downto 0) <= v9_ProgFullThresNegate_s;

        when OneHotVector(21,C_NUM_REG) =>
          slv_ip2bus_data(0) <= i_ParityAddrReg_p;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(22,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_NbRecordPorts_p;

        when OneHotVector(23,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_NbPlaybackPorts_p;

        when OneHotVector(24,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_RecordPortsWidth_p;

        when OneHotVector(25,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_PlaybackPortsWidth_p;

        when OneHotVector(26,C_NUM_REG) =>
          slv_ip2bus_data(0) <= RecTrigMux_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(27,C_NUM_REG) =>
          slv_ip2bus_data(0) <= RecSoftTrig_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(28,C_NUM_REG) =>
          slv_ip2bus_data(2 downto 0) <= iv3_ModeValidationValue_p;
          slv_ip2bus_data(31 downto 3) <= "00000000000000000000000000000";

        when OneHotVector(29,C_NUM_REG) =>
          slv_ip2bus_data(0) <= PlayTrigMux_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(30,C_NUM_REG) =>
          slv_ip2bus_data(0) <= PlaySoftTrig_s;
          slv_ip2bus_data(31 downto 1) <= "0000000000000000000000000000000";

        when OneHotVector(31,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= v32_Ddr3Size_s;

        when OneHotVector(32,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_RecordStorageCnt_p;

        when OneHotVector(33,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_RtdexStorageCnt_p;

        when OneHotVector(34,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_PlaybackReadCnt_p;

        when OneHotVector(35,C_NUM_REG) =>
          slv_ip2bus_data(31 downto 0) <= iv32_RtdexReadCnt_p;

        when others =>
          slv_ip2bus_data <= (others => '0');
      end case;

 end process SLAVE_REG_READ_PROC;

------------------------------------------
-- drive IP to Bus signals
------------------------------------------
IP2Bus_Data  <= slv_ip2bus_data when slv_read_ack = '1' else (others => '0');
IP2Bus_WrAck <= slv_write_ack;
IP2Bus_RdAck <= slv_read_ack;
IP2Bus_Error <= '0';

------------------------------------------
-- Output assignments
------------------------------------------
o_MemReset_p <= MemReset_s;
o_CoreReset_p <= CoreReset_s;
o_SetMode_p <= SetMode_s;
ov3_ModeValue_p <= v3_ModeValue_s;
o_SetStartAddress_p <= SetStartAddress_s;
ov32_StartAddress_p <= v32_StartAddress_s;
ov32_TrigDly_p <= v32_TrigDly_s;
o_SetTransferSize_p <= SetTransferSize_s;
ov32_TransferSize_p <= v32_TransferSize_s;
ov9_ProgFullThresAssert_p <= v9_ProgFullThresAssert_s;
ov9_ProgFullThresNegate_p <= v9_ProgFullThresNegate_s;
o_RecTrigMux_p <= RecTrigMux_s;
o_RecSoftTrig_p <= RecSoftTrig_s;
o_PlayTrigMux_p <= PlayTrigMux_s;
o_PlaySoftTrig_p <= PlaySoftTrig_s;

end IMP;

