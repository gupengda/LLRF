--------------------------------------------------------------------------------
-- Filename:          user_logic.vhd
-- Version:           v1_00_a
-- Description:       User Logic implementation module
-- Generated by:      julien.roy
-- Date:              2013-04-26 16:30:59
-- Generated:         using LyrtechRD REGGENUTIL based on Xilinx IPIF Wizard.
-- VHDL Standard:     VHDL'93
------------------------------------------------------------------------------
-- Copyright (c) 2001-2012 LYRtech RD Inc.  All rights reserved.
------------------------------------------------------------------------------
--
-----------------------------------------------------------------------------
-- Register Memory Map & Description
-----------------------------------------------------------------------------
-- BASEADDR + 0x0   COREID    Core ID & Version
--   31:0 coreId R

-- BASEADDR + 0x4   CONTROL    commands/status register
--   0:0 delay_reset R W O=o_delay_reset_p
--   1:1 clk_reset R W O=o_clk_reset_p
--   11:8 data_aligned R W O=ov4_data_aligned_p
--   2:2 io_reset R W O=o_io_reset_p
--   3:3 rsvd R
--   31:12 rsvd R
--   4:4 sync_cmd R W O=o_sync_cmd_p
--   5:5 CoreResetPulse P O=o_CoreResetPulse_p
--   6:6 RstFifo R W O=o_RstFifo_p
--   7:7 rsvd R

-- BASEADDR + 0x8   CALIB_CH_A    serdes and iodelay values for channel A
--   14:5 adcIdelayValueA_we P O=ov10_adcIdelayValueA_we_p
--   24:15 bitslipA P O=ov10_bitslipA_p
--   31:25 rsvd R
--   4:0 adcIdelayValueA R W O=ov5_adcIdelayValueA_p

-- BASEADDR + 0xc   CALIB_CH_B    serdes and iodelay values for channel B
--   14:5 adcIdelayValueB_we P O=ov10_adcIdelayValueB_we_p
--   24:15 bitslipB P O=ov10_bitslipB_p
--   31:25 rsvd R
--   4:0 adcIdelayValueB R W O=ov5_adcIdelayValueB_p

-- BASEADDR + 0x10   CALIB_CH_C    serdes and iodelay values for channel C
--   14:5 adcIdelayValueC_we P O=ov10_adcIdelayValueC_we_p
--   24:15 bitslipC P O=ov10_bitslipC_p
--   31:25 rsvd R
--   4:0 adcIdelayValueC R W O=ov5_adcIdelayValueC_p

-- BASEADDR + 0x14   CALIB_CH_D    serdes and iodelay values for channel D
--   14:5 adcIdelayValueD_we P O=ov10_adcIdelayValueD_we_p
--   24:15 bitslipD P O=ov10_bitslipD_p
--   31:25 rsvd R
--   4:0 adcIdelayValueD R W O=ov5_adcIdelayValueD_p

-- BASEADDR + 0x18   CALIB_ERROR_CH_A    bit calibration error for channel A
--   31:10 rsvd R
--   9:0 calibErrorChA R I=iv10_calibErrorChA_p

-- BASEADDR + 0x1c   CALIB_ERROR_CH_B    bit calibration error for channel B
--   31:10 rsvd R
--   9:0 calibErrorChB R I=iv10_calibErrorChB_p

-- BASEADDR + 0x20   CALIB_ERROR_CH_C    bit calibration error for channel C
--   31:10 rsvd R
--   9:0 calibErrorChC R I=iv10_calibErrorChC_p

-- BASEADDR + 0x24   CALIB_ERROR_CH_D    bit calibration error for channel D
--   31:10 rsvd R
--   9:0 calibErrorChD R I=iv10_calibErrorChD_p

-- BASEADDR + 0x28   TRIG_CMD    Trigger commands register
--   31:5 rsvd R
--   4:0 TriggerDelay R W O=ov5_TriggerDelay_p

-- BASEADDR + 0x2c   FEQCNTREG    Frequency module select signal for the clock that needs to be counted
--   15:0 FeqCntClkCnt R I=iv16_FeqCntClkCnt_p
--   19:16 FeqCntClkSel R W O=ov4_FeqCntClkSel_p
--   31:20 rsvd R

--------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

library proc_common_v3_00_a;
use proc_common_v3_00_a.proc_common_pkg.all;

-- DO NOT EDIT ABOVE THIS LINE --------------------

--USER libraries added here

------------------------------------------------------------------------------
-- Entity section
------------------------------------------------------------------------------
-- Definition of Generics:
--   C_NUM_REG                    -- Number of software accessible registers
--   C_SLV_DWIDTH                 -- Slave interface data bus width
--
-- Definition of Ports:
--   Bus2IP_Clk                   -- Bus to IP clock
--   Bus2IP_Resetn                -- Bus to IP reset
--   Bus2IP_Data                  -- Bus to IP data bus
--   Bus2IP_BE                    -- Bus to IP byte enables
--   Bus2IP_RdCE                  -- Bus to IP read chip enable
--   Bus2IP_WrCE                  -- Bus to IP write chip enable
--   IP2Bus_Data                  -- IP to Bus data bus
--   IP2Bus_RdAck                 -- IP to Bus read transfer acknowledgement
--   IP2Bus_WrAck                 -- IP to Bus write transfer acknowledgement
--   IP2Bus_Error                 -- IP to Bus error response
------------------------------------------------------------------------------

entity user_logic is
  generic
  (
    -- ADD USER GENERICS BELOW THIS LINE ---------------
    --USER generics added here
    -- ADD USER GENERICS ABOVE THIS LINE ---------------

    -- DO NOT EDIT BELOW THIS LINE ---------------------
    -- Bus protocol parameters, do not add to or delete
    C_NUM_REG                      : integer              := 12;
    C_SLV_DWIDTH                   : integer              := 32
    -- DO NOT EDIT ABOVE THIS LINE ---------------------
  );
  port
  (
    -- ADD USER PORTS BELOW THIS LINE ------------------
    --USER ports added here
    -- ADD USER PORTS ABOVE THIS LINE ------------------
    -- User ports
  i_CoreReset_p : in std_logic;

    o_delay_reset_p : out std_logic;
    o_clk_reset_p : out std_logic;
    ov4_data_aligned_p : out std_logic_vector(3 downto 0);
    o_io_reset_p : out std_logic;
    o_sync_cmd_p : out std_logic;
    o_CoreResetPulse_p : out std_logic;
    o_RstFifo_p : out std_logic;
    ov10_adcIdelayValueA_we_p : out std_logic_vector(9 downto 0);
    ov10_bitslipA_p : out std_logic_vector(9 downto 0);
    ov5_adcIdelayValueA_p : out std_logic_vector(4 downto 0);
    ov10_adcIdelayValueB_we_p : out std_logic_vector(9 downto 0);
    ov10_bitslipB_p : out std_logic_vector(9 downto 0);
    ov5_adcIdelayValueB_p : out std_logic_vector(4 downto 0);
    ov10_adcIdelayValueC_we_p : out std_logic_vector(9 downto 0);
    ov10_bitslipC_p : out std_logic_vector(9 downto 0);
    ov5_adcIdelayValueC_p : out std_logic_vector(4 downto 0);
    ov10_adcIdelayValueD_we_p : out std_logic_vector(9 downto 0);
    ov10_bitslipD_p : out std_logic_vector(9 downto 0);
    ov5_adcIdelayValueD_p : out std_logic_vector(4 downto 0);
    iv10_calibErrorChA_p : in std_logic_vector(9 downto 0);
    iv10_calibErrorChB_p : in std_logic_vector(9 downto 0);
    iv10_calibErrorChC_p : in std_logic_vector(9 downto 0);
    iv10_calibErrorChD_p : in std_logic_vector(9 downto 0);
    ov5_TriggerDelay_p : out std_logic_vector(4 downto 0);
    iv16_FeqCntClkCnt_p : in std_logic_vector(15 downto 0);
    ov4_FeqCntClkSel_p : out std_logic_vector(3 downto 0);
    o_FreqCntRst_p 	: out std_logic;
    -- Bus protocol ports, do not add to or delete
    Bus2IP_Clk                     : in  std_logic;
    Bus2IP_Resetn                  : in  std_logic;
    Bus2IP_Data                    : in  std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    Bus2IP_BE                      : in  std_logic_vector(C_SLV_DWIDTH/8-1 downto 0);
    Bus2IP_RdCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    Bus2IP_WrCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    IP2Bus_Data                    : out std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    IP2Bus_RdAck                   : out std_logic;
    IP2Bus_WrAck                   : out std_logic;
    IP2Bus_Error                   : out std_logic
  );

 attribute MAX_FANOUT : string;
 attribute SIGIS : string;
 attribute SIGIS of Bus2IP_Clk    : signal is "CLK";
 attribute SIGIS of Bus2IP_Resetn : signal is "RST";

end entity user_logic;

------------------------------------------------------------------------------
-- Architecture section
------------------------------------------------------------------------------

architecture IMP of user_logic is

-------------------------------------------------------------------------------
-- Constant declarations
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--     ************** Function declaratin *******************                   
-- Return a std_logic_vector with only one bit set to one.
-- The argument BitPosition represent the bit position to set to one, starting with 0.
-- The argument Width represent the width of the returned std_logic_vector.
-------------------------------------------------------------------------------
  function OneHotVector( BitPosition : integer;                              
                Width : integer)                                             
                return std_logic_vector                                      
  is                                                                         
    variable Result                   : std_logic_vector(Width - 1 downto 0);

  begin                        
    Result := (others => '0'); 
    Result(BitPosition) := '1';
    return Result;             
  end OneHotVector;            
-------------------------------------------------------------------------------
-- Signal and Type Declarations
-------------------------------------------------------------------------------

  signal delay_reset_s                     : std_logic;
  signal clk_reset_s                     : std_logic;
  signal v4_data_aligned_s                     : std_logic_vector(3 downto 0);
  signal io_reset_s                     : std_logic;
  signal sync_cmd_s                     : std_logic;
  signal CoreResetPulse_s                     : std_logic;
  signal RstFifo_s                     : std_logic;
  signal v10_adcIdelayValueA_we_s                     : std_logic_vector(9 downto 0);
  signal v10_bitslipA_s                     : std_logic_vector(9 downto 0);
  signal v5_adcIdelayValueA_s                     : std_logic_vector(4 downto 0);
  signal v10_adcIdelayValueB_we_s                     : std_logic_vector(9 downto 0);
  signal v10_bitslipB_s                     : std_logic_vector(9 downto 0);
  signal v5_adcIdelayValueB_s                     : std_logic_vector(4 downto 0);
  signal v10_adcIdelayValueC_we_s                     : std_logic_vector(9 downto 0);
  signal v10_bitslipC_s                     : std_logic_vector(9 downto 0);
  signal v5_adcIdelayValueC_s                     : std_logic_vector(4 downto 0);
  signal v10_adcIdelayValueD_we_s                     : std_logic_vector(9 downto 0);
  signal v10_bitslipD_s                     : std_logic_vector(9 downto 0);
  signal v5_adcIdelayValueD_s                     : std_logic_vector(4 downto 0);
  signal v5_TriggerDelay_s                     : std_logic_vector(4 downto 0);
  signal v4_FeqCntClkSel_s                     : std_logic_vector(3 downto 0);
  signal slv_reg_write_sel              : std_logic_vector(11 downto 0);
  signal slv_reg_read_sel               : std_logic_vector(11 downto 0);
  signal slv_ip2bus_data                : std_logic_vector(C_SLV_DWIDTH-1 downto 0);
  signal slv_read_ack                   : std_logic;
  signal slv_write_ack                  : std_logic;
  signal FreqCntRst_s                   : std_logic;   

------------------------------------------------------------------------------
begin
------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Begin architecture
-------------------------------------------------------------------------------

-- swap bits
WrCeBitSwap: for i in 0 to slv_reg_write_sel'high generate
  slv_reg_write_sel(i) <= Bus2IP_WrCE(slv_reg_write_sel'high - i);
end generate WrCeBitSwap;

RdCeBitSwap: for i in 0 to slv_reg_read_sel'high generate
  slv_reg_read_sel(i)  <= Bus2IP_RdCE(slv_reg_read_sel'high - i);
end generate RdCeBitSwap;

-- generate write/read ack
  slv_write_ack <=   Bus2IP_WrCE(0) or   Bus2IP_WrCE(1) or   Bus2IP_WrCE(2) or   Bus2IP_WrCE(3) or   Bus2IP_WrCE(4) or   Bus2IP_WrCE(5) or   Bus2IP_WrCE(6) or   Bus2IP_WrCE(7) or   Bus2IP_WrCE(8) or   Bus2IP_WrCE(9) or   Bus2IP_WrCE(10) or   Bus2IP_WrCE(11);
  slv_read_ack  <=   Bus2IP_RdCE(0) or   Bus2IP_RdCE(1) or   Bus2IP_RdCE(2) or   Bus2IP_RdCE(3) or   Bus2IP_RdCE(4) or   Bus2IP_RdCE(5) or   Bus2IP_RdCE(6) or   Bus2IP_RdCE(7) or   Bus2IP_RdCE(8) or   Bus2IP_RdCE(9) or   Bus2IP_RdCE(10) or   Bus2IP_RdCE(11);

 -- implement slave model software accessible register(s)
 SLAVE_REG_WRITE_PROC : process( Bus2IP_Clk ) is
 begin

  if Bus2IP_Clk'event and Bus2IP_Clk = '1' then
    if (Bus2IP_Resetn = '0') or (i_CoreReset_p = '1') then
      delay_reset_s <= '1';
      clk_reset_s <= '1';
      v4_data_aligned_s <= x"0";
      io_reset_s <= '1';
      sync_cmd_s <= '0';
      CoreResetPulse_s <= '0';
      RstFifo_s <= '0';
      v10_adcIdelayValueA_we_s <= "0000000000";
      v10_bitslipA_s <= "0000000000";
      v5_adcIdelayValueA_s <= "00000";
      v10_adcIdelayValueB_we_s <= "0000000000";
      v10_bitslipB_s <= "0000000000";
      v5_adcIdelayValueB_s <= "00000";
      v10_adcIdelayValueC_we_s <= "0000000000";
      v10_bitslipC_s <= "0000000000";
      v5_adcIdelayValueC_s <= "00000";
      v10_adcIdelayValueD_we_s <= "0000000000";
      v10_bitslipD_s <= "0000000000";
      v5_adcIdelayValueD_s <= "00000";
      v5_TriggerDelay_s <= "01011";
      v4_FeqCntClkSel_s <= x"0";
      FreqCntRst_s <= '1';

    else

    	-- default values to creat a pulse on signals
    	delay_reset_s <= '0';
    	clk_reset_s <= '0';
    	io_reset_s <= '0'; 
    	FreqCntRst_s <= '0';

  CoreResetPulse_s <= '0';
  v10_adcIdelayValueA_we_s <= "0000000000";
  v10_bitslipA_s <= "0000000000";
  v10_adcIdelayValueB_we_s <= "0000000000";
  v10_bitslipB_s <= "0000000000";
  v10_adcIdelayValueC_we_s <= "0000000000";
  v10_bitslipC_s <= "0000000000";
  v10_adcIdelayValueD_we_s <= "0000000000";
  v10_bitslipD_s <= "0000000000";
      case slv_reg_write_sel is

        when OneHotVector(1,12) =>
          if (Bus2IP_BE(0) = '1') then
            delay_reset_s <= Bus2IP_Data(0);
          end if;
          if (Bus2IP_BE(0) = '1') then
            clk_reset_s <= Bus2IP_Data(1);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v4_data_aligned_s <= Bus2IP_Data(11 downto 8);
          end if;
          if (Bus2IP_BE(0) = '1') then
            io_reset_s <= Bus2IP_Data(2);
          end if;
          if (Bus2IP_BE(0) = '1') then
            sync_cmd_s <= Bus2IP_Data(4);
          end if;
          if (Bus2IP_BE(0) = '1') then
            CoreResetPulse_s <= Bus2IP_Data(5);
          end if;
          if (Bus2IP_BE(0) = '1') then
            RstFifo_s <= Bus2IP_Data(6);
          end if;

        when OneHotVector(2,12) =>
          if (Bus2IP_BE(0) = '1') then
            v10_adcIdelayValueA_we_s(2 downto 0) <= Bus2IP_Data(7 downto 5);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_adcIdelayValueA_we_s(9 downto 3) <= Bus2IP_Data(14 downto 8);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_bitslipA_s(0) <= Bus2IP_Data(15);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v10_bitslipA_s(8 downto 1) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v10_bitslipA_s(9 downto 9) <= Bus2IP_Data(24 downto 24);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_adcIdelayValueA_s <= Bus2IP_Data(4 downto 0);
          end if;

        when OneHotVector(3,12) =>
          if (Bus2IP_BE(0) = '1') then
            v10_adcIdelayValueB_we_s(2 downto 0) <= Bus2IP_Data(7 downto 5);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_adcIdelayValueB_we_s(9 downto 3) <= Bus2IP_Data(14 downto 8);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_bitslipB_s(0) <= Bus2IP_Data(15);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v10_bitslipB_s(8 downto 1) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v10_bitslipB_s(9 downto 9) <= Bus2IP_Data(24 downto 24);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_adcIdelayValueB_s <= Bus2IP_Data(4 downto 0);
          end if;

        when OneHotVector(4,12) =>
          if (Bus2IP_BE(0) = '1') then
            v10_adcIdelayValueC_we_s(2 downto 0) <= Bus2IP_Data(7 downto 5);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_adcIdelayValueC_we_s(9 downto 3) <= Bus2IP_Data(14 downto 8);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_bitslipC_s(0) <= Bus2IP_Data(15);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v10_bitslipC_s(8 downto 1) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v10_bitslipC_s(9 downto 9) <= Bus2IP_Data(24 downto 24);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_adcIdelayValueC_s <= Bus2IP_Data(4 downto 0);
          end if;

        when OneHotVector(5,12) =>
          if (Bus2IP_BE(0) = '1') then
            v10_adcIdelayValueD_we_s(2 downto 0) <= Bus2IP_Data(7 downto 5);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_adcIdelayValueD_we_s(9 downto 3) <= Bus2IP_Data(14 downto 8);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v10_bitslipD_s(0) <= Bus2IP_Data(15);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v10_bitslipD_s(8 downto 1) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v10_bitslipD_s(9 downto 9) <= Bus2IP_Data(24 downto 24);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_adcIdelayValueD_s <= Bus2IP_Data(4 downto 0);
          end if;

        when OneHotVector(10,12) =>
          if (Bus2IP_BE(0) = '1') then
            v5_TriggerDelay_s <= Bus2IP_Data(4 downto 0);
          end if;

        when OneHotVector(11,12) =>
          if (Bus2IP_BE(2) = '1') then
            v4_FeqCntClkSel_s <= Bus2IP_Data(19 downto 16);
          	FreqCntRst_s <= '1';
          end if;
        when others =>
          null;
      end case;
    end if;
  end if;

 end process SLAVE_REG_WRITE_PROC;

 -- implement slave model software accessible register(s) read mux
SLAVE_REG_READ_PROC : process( slv_reg_read_sel, delay_reset_s, clk_reset_s, v4_data_aligned_s, io_reset_s, sync_cmd_s, RstFifo_s, v5_adcIdelayValueA_s, v5_adcIdelayValueB_s, v5_adcIdelayValueC_s, v5_adcIdelayValueD_s, iv10_calibErrorChA_p, iv10_calibErrorChB_p, iv10_calibErrorChC_p, iv10_calibErrorChD_p, v5_TriggerDelay_s, iv16_FeqCntClkCnt_p, v4_FeqCntClkSel_s) is
 begin
   case slv_reg_read_sel is

        when OneHotVector(0,12) =>
          slv_ip2bus_data(31 downto 0) <= X"ADC50201";

        when OneHotVector(1,12) =>
          slv_ip2bus_data(0) <= delay_reset_s;
          slv_ip2bus_data(1) <= clk_reset_s;
          slv_ip2bus_data(11 downto 8) <= v4_data_aligned_s;
          slv_ip2bus_data(2) <= io_reset_s;
          slv_ip2bus_data(3) <= '0';
          slv_ip2bus_data(31 downto 12) <= x"00000";
          slv_ip2bus_data(4) <= sync_cmd_s;
          slv_ip2bus_data(6) <= RstFifo_s;
          slv_ip2bus_data(7) <= '0';

        when OneHotVector(2,12) =>
          slv_ip2bus_data(31 downto 25) <= "0000000";
          slv_ip2bus_data(4 downto 0) <= v5_adcIdelayValueA_s;

        when OneHotVector(3,12) =>
          slv_ip2bus_data(31 downto 25) <= "0000000";
          slv_ip2bus_data(4 downto 0) <= v5_adcIdelayValueB_s;

        when OneHotVector(4,12) =>
          slv_ip2bus_data(31 downto 25) <= "0000000";
          slv_ip2bus_data(4 downto 0) <= v5_adcIdelayValueC_s;

        when OneHotVector(5,12) =>
          slv_ip2bus_data(31 downto 25) <= "0000000";
          slv_ip2bus_data(4 downto 0) <= v5_adcIdelayValueD_s;

        when OneHotVector(6,12) =>
          slv_ip2bus_data(31 downto 10) <= "0000000000000000000000";
          slv_ip2bus_data(9 downto 0) <= iv10_calibErrorChA_p;

        when OneHotVector(7,12) =>
          slv_ip2bus_data(31 downto 10) <= "0000000000000000000000";
          slv_ip2bus_data(9 downto 0) <= iv10_calibErrorChB_p;

        when OneHotVector(8,12) =>
          slv_ip2bus_data(31 downto 10) <= "0000000000000000000000";
          slv_ip2bus_data(9 downto 0) <= iv10_calibErrorChC_p;

        when OneHotVector(9,12) =>
          slv_ip2bus_data(31 downto 10) <= "0000000000000000000000";
          slv_ip2bus_data(9 downto 0) <= iv10_calibErrorChD_p;

        when OneHotVector(10,12) =>
          slv_ip2bus_data(31 downto 5) <= "000000000000000000000000000";
          slv_ip2bus_data(4 downto 0) <= v5_TriggerDelay_s;

        when OneHotVector(11,12) =>
          slv_ip2bus_data(15 downto 0) <= iv16_FeqCntClkCnt_p;
          slv_ip2bus_data(19 downto 16) <= v4_FeqCntClkSel_s;
          slv_ip2bus_data(31 downto 20) <= x"000";
        when others =>
          slv_ip2bus_data <= (others => '0');
      end case;

 end process SLAVE_REG_READ_PROC;

------------------------------------------
-- drive IP to Bus signals
------------------------------------------
IP2Bus_Data  <= slv_ip2bus_data when slv_read_ack = '1' else (others => '0');
IP2Bus_WrAck <= slv_write_ack;
IP2Bus_RdAck <= slv_read_ack;
IP2Bus_Error <= '0';

------------------------------------------
-- Output assignments
------------------------------------------
o_delay_reset_p <= delay_reset_s;
o_clk_reset_p <= clk_reset_s;
ov4_data_aligned_p <= v4_data_aligned_s;
o_io_reset_p <= io_reset_s;
o_sync_cmd_p <= sync_cmd_s;
o_CoreResetPulse_p <= CoreResetPulse_s;
o_RstFifo_p <= RstFifo_s;
ov10_adcIdelayValueA_we_p <= v10_adcIdelayValueA_we_s;
ov10_bitslipA_p <= v10_bitslipA_s;
ov5_adcIdelayValueA_p <= v5_adcIdelayValueA_s;
ov10_adcIdelayValueB_we_p <= v10_adcIdelayValueB_we_s;
ov10_bitslipB_p <= v10_bitslipB_s;
ov5_adcIdelayValueB_p <= v5_adcIdelayValueB_s;
ov10_adcIdelayValueC_we_p <= v10_adcIdelayValueC_we_s;
ov10_bitslipC_p <= v10_bitslipC_s;
ov5_adcIdelayValueC_p <= v5_adcIdelayValueC_s;
ov10_adcIdelayValueD_we_p <= v10_adcIdelayValueD_we_s;
ov10_bitslipD_p <= v10_bitslipD_s;
ov5_adcIdelayValueD_p <= v5_adcIdelayValueD_s;
ov5_TriggerDelay_p <= v5_TriggerDelay_s;
o_FreqCntRst_p <= FreqCntRst_s;
ov4_FeqCntClkSel_p <= v4_FeqCntClkSel_s;

end IMP;

