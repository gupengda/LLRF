--------------------------------------------------------------------------------
-- Filename:          user_logic.vhd
-- Version:           v1_00_a
-- Description:       User Logic implementation module
-- Generated by:      julien.roy
-- Date:              2013-03-19 12:02:28
-- Generated:         using Nutaq RD REGGENUTIL based on Xilinx IPIF Wizard.
-- VHDL Standard:     VHDL'93
------------------------------------------------------------------------------
-- Copyright (c) 2013 Nutaq RD Inc.  All rights reserved.
------------------------------------------------------------------------------
--
-----------------------------------------------------------------------------
-- Register Memory Map & Description
-----------------------------------------------------------------------------
-- BASEADDR + 0x0   REG1   MdioCtrlReg
--   12:11 TransactionType R W O=ov2_TransactionType_p
--   13:13 ExtendedAdrsSpc R W O=o_ExtendedAdrsSpc_p
--   15:15 TransactionRq R W I=i_TransactionRq_p O=o_TransactionRq_p R=i_TransactionRqRst_p
--   4:0 RegAddress R W O=ov5_RegAddress_p
--   9:5 PortAddress R W O=ov5_PortAddress_p

-- BASEADDR + 0x4   REG2   MdioDataReg
--   15:0 Data R W I=iv16_Data_p O=ov16_Data_p

-- BASEADDR + 0x8   REG3   SFPCtrlReg
--   0:0 ResetN R W O=o_ResetN_p
--   10:10 ResetErrCnt R W O=o_ResetErrCnt_p
--   11:11 EnPktGen R W O=o_EnPktGen_p
--   1:1 ClkSel R W O=o_ClkSel_p
--   2:2 EnClk156 R W O=o_EnClk156_p
--   31:12 PacketSize R W O=ov20_PacketSize_p
--   3:3 EnClkUser R W O=o_EnClkUser_p
--   6:4 MgtLoopbackA R W O=ov3_MgtLoopbackA_p
--   9:7 MgtLoopbackB R W O=ov3_MgtLoopbackB_p

-- BASEADDR + 0xc   REG4   CntRxValidPacketA
--   15:0 CntRxValidPacketA R I=iv16_CntRxValidPacketA_p

-- BASEADDR + 0x10   REG5   CntRxCorruptPacketA
--   15:0 CntRxCorruptPacketA R I=iv16_CntRxCorruptPacketA_p

-- BASEADDR + 0x14   REG6   CntRxValidPacketB
--   15:0 CntRxValidPacketB R I=iv16_CntRxValidPacketB_p

-- BASEADDR + 0x18   REG7   CntRxCorruptPacketB
--   15:0 CntRxCorruptPacketB R I=iv16_CntRxCorruptPacketB_p

-- BASEADDR + 0x1c   REG8   SFPClkStatusReg
--   0:0 FmcRefClk0Status R I=i_FmcRefClk0Status_p
--   1:1 FmcRefClk1Status R I=i_FmcRefClk1Status_p
--   2:2 M2CClk0Status R I=i_M2CClk0Status_p
--   3:3 M2CClk1Status R I=i_M2CClk1Status_p

--------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

library proc_common_v3_00_a;
use proc_common_v3_00_a.proc_common_pkg.all;

-- DO NOT EDIT ABOVE THIS LINE --------------------

--USER libraries added here

------------------------------------------------------------------------------
-- Entity section
------------------------------------------------------------------------------
-- Definition of Generics:
--   C_NUM_REG                    -- Number of software accessible registers
--   C_SLV_DWIDTH                 -- Slave interface data bus width
--
-- Definition of Ports:
--   Bus2IP_Clk                   -- Bus to IP clock
--   Bus2IP_Resetn                -- Bus to IP reset
--   Bus2IP_Data                  -- Bus to IP data bus
--   Bus2IP_BE                    -- Bus to IP byte enables
--   Bus2IP_RdCE                  -- Bus to IP read chip enable
--   Bus2IP_WrCE                  -- Bus to IP write chip enable
--   IP2Bus_Data                  -- IP to Bus data bus
--   IP2Bus_RdAck                 -- IP to Bus read transfer acknowledgement
--   IP2Bus_WrAck                 -- IP to Bus write transfer acknowledgement
--   IP2Bus_Error                 -- IP to Bus error response
------------------------------------------------------------------------------

entity user_logic is
  generic
  (
    -- ADD USER GENERICS BELOW THIS LINE ---------------
    --USER generics added here
    -- ADD USER GENERICS ABOVE THIS LINE ---------------

    -- DO NOT EDIT BELOW THIS LINE ---------------------
    -- Bus protocol parameters, do not add to or delete
    C_NUM_REG                      : integer              := 8;
    C_SLV_DWIDTH                   : integer              := 32
    -- DO NOT EDIT ABOVE THIS LINE ---------------------
  );
  port
  (
    -- User ports
    i_CoreReset_p                  : in std_logic;
    ov2_TransactionType_p          : out std_logic_vector(1 downto 0);
    o_ExtendedAdrsSpc_p            : out std_logic;
    i_TransactionRq_p              : in std_logic;
    o_TransactionRq_p              : out std_logic;
    i_TransactionRqRst_p           : in std_logic;
    ov5_RegAddress_p               : out std_logic_vector(4 downto 0);
    ov5_PortAddress_p              : out std_logic_vector(4 downto 0);
    iv16_Data_p                    : in std_logic_vector(15 downto 0);
    ov16_Data_p                    : out std_logic_vector(15 downto 0);
    o_ResetN_p : out std_logic;
    o_ResetErrCnt_p : out std_logic;
    o_EnPktGen_p : out std_logic;
    o_ClkSel_p : out std_logic;
    o_EnClk156_p : out std_logic;
    ov20_PacketSize_p : out std_logic_vector(19 downto 0);
    o_EnClkUser_p : out std_logic;
    ov3_MgtLoopbackA_p : out std_logic_vector(2 downto 0);
    ov3_MgtLoopbackB_p : out std_logic_vector(2 downto 0);
    iv16_CntRxValidPacketA_p : in std_logic_vector(15 downto 0);
    iv16_CntRxCorruptPacketA_p : in std_logic_vector(15 downto 0);
    iv16_CntRxValidPacketB_p : in std_logic_vector(15 downto 0);
    iv16_CntRxCorruptPacketB_p : in std_logic_vector(15 downto 0);
    i_FmcRefClk0Status_p : in std_logic;
    i_FmcRefClk1Status_p : in std_logic;
    i_M2CClk0Status_p : in std_logic;
    i_M2CClk1Status_p : in std_logic;
    -- Bus protocol ports, do not add to or delete
    Bus2IP_Clk                     : in  std_logic;
    Bus2IP_Resetn                  : in  std_logic;
    Bus2IP_Data                    : in  std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    Bus2IP_BE                      : in  std_logic_vector(C_SLV_DWIDTH/8-1 downto 0);
    Bus2IP_RdCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    Bus2IP_WrCE                    : in  std_logic_vector(C_NUM_REG-1 downto 0);
    IP2Bus_Data                    : out std_logic_vector(C_SLV_DWIDTH-1 downto 0);
    IP2Bus_RdAck                   : out std_logic;
    IP2Bus_WrAck                   : out std_logic;
    IP2Bus_Error                   : out std_logic
  );

 attribute MAX_FANOUT : string;
 attribute SIGIS : string;
 attribute SIGIS of Bus2IP_Clk    : signal is "CLK";
 attribute SIGIS of Bus2IP_Resetn : signal is "RST";

end entity user_logic;

-------------------------------------------------------------------------------
-- Architecture Section
-------------------------------------------------------------------------------

architecture IMP of user_logic is

-------------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--     ************** Function declaratin *******************                   
-- Return a std_logic_vector with only one bit set to one.
-- The argument BitPosition represent the bit position to set to one, starting with 0.
-- The argument Width represent the width of the returned std_logic_vector.
-------------------------------------------------------------------------------
  function OneHotVector( BitPosition : integer;                              
                Width : integer)                                             
                return std_logic_vector                                      
  is                                                                         
    variable Result                   : std_logic_vector(Width - 1 downto 0);

  begin                        
    Result := (others => '0'); 
    Result(BitPosition) := '1';
    return Result;             
  end OneHotVector;              
-------------------------------------------------------------------------------
-- Signal and Type Declarations
-------------------------------------------------------------------------------


  signal v2_TransactionType_s                     : std_logic_vector(1 downto 0);
  signal ExtendedAdrsSpc_s                     : std_logic;
  signal TransactionRq_s                     : std_logic;
  signal v5_RegAddress_s                     : std_logic_vector(4 downto 0);
  signal v5_PortAddress_s                     : std_logic_vector(4 downto 0);
  signal v16_Data_s                     : std_logic_vector(15 downto 0);
  signal ResetN_s                     : std_logic;
  signal ResetErrCnt_s                     : std_logic;
  signal EnPktGen_s                     : std_logic;
  signal ClkSel_s                     : std_logic;
  signal EnClk156_s                     : std_logic;
  signal v20_PacketSize_s                     : std_logic_vector(19 downto 0);
  signal EnClkUser_s                     : std_logic;
  signal v3_MgtLoopbackA_s                     : std_logic_vector(2 downto 0);
  signal v3_MgtLoopbackB_s                     : std_logic_vector(2 downto 0);
  signal slv_reg_write_sel              : std_logic_vector(7 downto 0);
  signal slv_reg_read_sel               : std_logic_vector(7 downto 0);
  signal slv_ip2bus_data                : std_logic_vector(C_SLV_DWIDTH-1 downto 0);
  signal slv_read_ack                   : std_logic;
  signal slv_write_ack                  : std_logic;


------------------------------------------------------------------------------
begin
------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Begin architecture
-------------------------------------------------------------------------------

-- swap bits
WrCeBitSwap: for i in 0 to slv_reg_write_sel'high generate
  slv_reg_write_sel(i) <= Bus2IP_WrCE(slv_reg_write_sel'high - i);
end generate WrCeBitSwap;

RdCeBitSwap: for i in 0 to slv_reg_read_sel'high generate
  slv_reg_read_sel(i)  <= Bus2IP_RdCE(slv_reg_read_sel'high - i);
end generate RdCeBitSwap;

-- generate write/read ack
slv_write_ack <= Bus2IP_WrCE(0) or Bus2IP_WrCE(1) or Bus2IP_WrCE(2) or Bus2IP_WrCE(3) or Bus2IP_WrCE(4) or Bus2IP_WrCE(5) or Bus2IP_WrCE(6) or Bus2IP_WrCE(7);
slv_read_ack  <= Bus2IP_RdCE(0) or Bus2IP_RdCE(1) or Bus2IP_RdCE(2) or Bus2IP_RdCE(3) or Bus2IP_RdCE(4) or Bus2IP_RdCE(5) or Bus2IP_RdCE(6) or Bus2IP_RdCE(7);

 -- implement slave model software accessible register(s)
 SLAVE_REG_WRITE_PROC : process( Bus2IP_Clk ) is
 begin
  if Bus2IP_Clk'event and Bus2IP_Clk = '1' then
    if Bus2IP_Resetn = '0' then
      v2_TransactionType_s <= "00";
      ExtendedAdrsSpc_s <= '0';
      TransactionRq_s <= '0';
      v5_RegAddress_s <= "00000";
      v5_PortAddress_s <= "00000";
      v16_Data_s <= x"0000";
      ResetN_s <= '1';
      ResetErrCnt_s <= '0';
      EnPktGen_s <= '0';
      ClkSel_s <= '0';
      EnClk156_s <= '0';
      v20_PacketSize_s <= x"00000";
      EnClkUser_s <= '0';
      v3_MgtLoopbackA_s <= "000";
      v3_MgtLoopbackB_s <= "000";

    else

      -- Synchronous reset
      if ( i_CoreReset_p = '1' ) then
        v2_TransactionType_s <= "00";
        ExtendedAdrsSpc_s <= '0';
        TransactionRq_s <= '0';
        v5_RegAddress_s <= "00000";
        v5_PortAddress_s <= "00000";
        v16_Data_s <= x"0000";
        ResetN_s <= '1';
        ResetErrCnt_s <= '0';
        EnPktGen_s <= '0';
        ClkSel_s <= '0';
        EnClk156_s <= '0';
        v20_PacketSize_s <= x"00000";
        EnClkUser_s <= '0';
        v3_MgtLoopbackA_s <= "000";
        v3_MgtLoopbackB_s <= "000";
      end if;

      if ( i_TransactionRqRst_p = '1' ) then
        TransactionRq_s <= '0';
      end if;
      case slv_reg_write_sel is
      
        when OneHotVector(0,8) =>
          if (Bus2IP_BE(1) = '1') then
            v2_TransactionType_s <= Bus2IP_Data(12 downto 11);
          end if;
          if (Bus2IP_BE(1) = '1') then
            ExtendedAdrsSpc_s <= Bus2IP_Data(13);
          end if;
          if (Bus2IP_BE(1) = '1') then
            TransactionRq_s <= Bus2IP_Data(15);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_RegAddress_s <= Bus2IP_Data(4 downto 0);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v5_PortAddress_s(2 downto 0) <= Bus2IP_Data(7 downto 5);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v5_PortAddress_s(4 downto 3) <= Bus2IP_Data(9 downto 8);
          end if;

        when OneHotVector(1,8) =>
          if (Bus2IP_BE(0) = '1') then
            v16_Data_s(7 downto 0) <= Bus2IP_Data(7 downto 0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v16_Data_s(15 downto 8) <= Bus2IP_Data(15 downto 8);
          end if;

        when OneHotVector(2,8) =>
          if (Bus2IP_BE(0) = '1') then
            ResetN_s <= Bus2IP_Data(0);
          end if;
          if (Bus2IP_BE(1) = '1') then
            ResetErrCnt_s <= Bus2IP_Data(10);
          end if;
          if (Bus2IP_BE(1) = '1') then
            EnPktGen_s <= Bus2IP_Data(11);
          end if;
          if (Bus2IP_BE(0) = '1') then
            ClkSel_s <= Bus2IP_Data(1);
          end if;
          if (Bus2IP_BE(0) = '1') then
            EnClk156_s <= Bus2IP_Data(2);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v20_PacketSize_s(3 downto 0) <= Bus2IP_Data(15 downto 12);
          end if;
          if (Bus2IP_BE(2) = '1') then
            v20_PacketSize_s(11 downto 4) <= Bus2IP_Data(23 downto 16);
          end if;
          if (Bus2IP_BE(3) = '1') then
            v20_PacketSize_s(19 downto 12) <= Bus2IP_Data(31 downto 24);
          end if;
          if (Bus2IP_BE(0) = '1') then
            EnClkUser_s <= Bus2IP_Data(3);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v3_MgtLoopbackA_s <= Bus2IP_Data(6 downto 4);
          end if;
          if (Bus2IP_BE(0) = '1') then
            v3_MgtLoopbackB_s(0) <= Bus2IP_Data(7);
          end if;
          if (Bus2IP_BE(1) = '1') then
            v3_MgtLoopbackB_s(2 downto 1) <= Bus2IP_Data(9 downto 8);
          end if;
        when others =>
          null;
      end case;
    end if;
  end if;

 end process SLAVE_REG_WRITE_PROC;

 -- implement slave model software accessible register(s) read mux
SLAVE_REG_READ_PROC : process( slv_reg_read_sel, v2_TransactionType_s, ExtendedAdrsSpc_s, i_TransactionRq_p, v5_RegAddress_s, v5_PortAddress_s, iv16_Data_p, ResetN_s, ResetErrCnt_s, EnPktGen_s, ClkSel_s, EnClk156_s, v20_PacketSize_s, EnClkUser_s, v3_MgtLoopbackA_s, v3_MgtLoopbackB_s, iv16_CntRxValidPacketA_p, iv16_CntRxCorruptPacketA_p, iv16_CntRxValidPacketB_p, iv16_CntRxCorruptPacketB_p, i_FmcRefClk0Status_p, i_FmcRefClk1Status_p, i_M2CClk0Status_p, i_M2CClk1Status_p) is
 begin
   case slv_reg_read_sel is

        when OneHotVector(0,8) =>
          slv_ip2bus_data(12 downto 11) <= v2_TransactionType_s;
          slv_ip2bus_data(13) <= ExtendedAdrsSpc_s;
          slv_ip2bus_data(15) <= i_TransactionRq_p;
          slv_ip2bus_data(4 downto 0) <= v5_RegAddress_s;
          slv_ip2bus_data(9 downto 5) <= v5_PortAddress_s;

        when OneHotVector(1,8) =>
          slv_ip2bus_data(15 downto 0) <= iv16_Data_p;

        when OneHotVector(2,8) =>
          slv_ip2bus_data(0) <= ResetN_s;
          slv_ip2bus_data(10) <= ResetErrCnt_s;
          slv_ip2bus_data(11) <= EnPktGen_s;
          slv_ip2bus_data(1) <= ClkSel_s;
          slv_ip2bus_data(2) <= EnClk156_s;
          slv_ip2bus_data(31 downto 12) <= v20_PacketSize_s;
          slv_ip2bus_data(3) <= EnClkUser_s;
          slv_ip2bus_data(6 downto 4) <= v3_MgtLoopbackA_s;
          slv_ip2bus_data(9 downto 7) <= v3_MgtLoopbackB_s;

        when OneHotVector(3,8) =>
          slv_ip2bus_data(15 downto 0) <= iv16_CntRxValidPacketA_p;

        when OneHotVector(4,8) =>
          slv_ip2bus_data(15 downto 0) <= iv16_CntRxCorruptPacketA_p;

        when OneHotVector(5,8) =>
          slv_ip2bus_data(15 downto 0) <= iv16_CntRxValidPacketB_p;

        when OneHotVector(6,8) =>
          slv_ip2bus_data(15 downto 0) <= iv16_CntRxCorruptPacketB_p;

        when OneHotVector(7,8) =>
          slv_ip2bus_data(0) <= i_FmcRefClk0Status_p;
          slv_ip2bus_data(1) <= i_FmcRefClk1Status_p;
          slv_ip2bus_data(2) <= i_M2CClk0Status_p;
          slv_ip2bus_data(3) <= i_M2CClk1Status_p;
        when others =>
          slv_ip2bus_data <= (others => '0');
      end case;

 end process SLAVE_REG_READ_PROC;

------------------------------------------
-- drive IP to Bus signals
------------------------------------------
IP2Bus_Data  <= slv_ip2bus_data when slv_read_ack = '1' else (others => '0');
IP2Bus_WrAck <= slv_write_ack;
IP2Bus_RdAck <= slv_read_ack;
IP2Bus_Error <= '0';

------------------------------------------
-- Output assignments
------------------------------------------
ov2_TransactionType_p <= v2_TransactionType_s;
o_ExtendedAdrsSpc_p <= ExtendedAdrsSpc_s;
o_TransactionRq_p <= TransactionRq_s;
ov5_RegAddress_p <= v5_RegAddress_s;
ov5_PortAddress_p <= v5_PortAddress_s;
ov16_Data_p <= v16_Data_s;
o_ResetN_p <= ResetN_s;
o_ResetErrCnt_p <= ResetErrCnt_s;
o_EnPktGen_p <= EnPktGen_s;
o_ClkSel_p <= ClkSel_s;
o_EnClk156_p <= EnClk156_s;
ov20_PacketSize_p <= v20_PacketSize_s;
o_EnClkUser_p <= EnClkUser_s;
ov3_MgtLoopbackA_p <= v3_MgtLoopbackA_s;
ov3_MgtLoopbackB_p <= v3_MgtLoopbackB_s;

end architecture IMP;

